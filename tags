!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AC_READ	protocal.h	/^typedef enum { AC_READ=0, AC_WRITE=1 }ac_type;$/;"	e	enum:__anon2
AC_WRITE	protocal.h	/^typedef enum { AC_READ=0, AC_WRITE=1 }ac_type;$/;"	e	enum:__anon2
CC	makefile	/^CC=gcc$/;"	m
CFLAGS	makefile	/^CFLAGS=-g$/;"	m
ERROR_sig	main.c	80;"	d	file:
GETTIMEOFDAY	libc.c	/^	GETTIMEOFDAY = 1,$/;"	e	enum:__anon4	file:
IA32	libc.c	12;"	d	file:
INIT_LIBC_ROUTINE	main.c	47;"	d	file:
LDFLAGS	makefile	/^LDFLAGS=-ldl -pthread -fPIC -shared$/;"	m
LIB	makefile	/^LIB=libxxx.so$/;"	m
OWNED_WRITE	protocal.h	/^typedef enum { PUBLIC=0, SHARED_READ=1, OWNED_WRITE=2}page_state;$/;"	e	enum:__anon1
PF_PROT	main.c	82;"	d	file:
PF_WRITE	main.c	83;"	d	file:
POT_ITEM_NUMBER	global.h	8;"	d
PUBLIC	protocal.h	/^typedef enum { PUBLIC=0, SHARED_READ=1, OWNED_WRITE=2}page_state;$/;"	e	enum:__anon1
RIP_sig	main.c	81;"	d	file:
SHARED_READ	protocal.h	/^typedef enum { PUBLIC=0, SHARED_READ=1, OWNED_WRITE=2}page_state;$/;"	e	enum:__anon1
SO_PATH	script.c	12;"	d	file:
SPIN_LOCK_UNLOCKED	global.h	29;"	d
STR_MAX	libc.c	27;"	d	file:
TEST	makefile	/^TEST=test$/;"	m
TESTFLAGS	makefile	/^TESTFLAGS=-pthread$/;"	m
WRAPPER	makefile	/^WRAPPER=btrecorder$/;"	m
_GLOBAL_H_	global.h	3;"	d
_GNU_SOURCE	main.c	1;"	d	file:
_PROTOCAL_H_	protocal.h	3;"	d
__libc_start_main	main.c	/^int __libc_start_main(int (* main) (int, char **, char **),$/;"	f
_exit	libc.c	/^void _exit (int status)$/;"	f
_libc_exit	main.c	/^void (* _libc_exit)(int) = NULL;$/;"	v
_libc_gettimeofday	main.c	/^int (* _libc_gettimeofday)(struct timeval *, struct timezone *) = NULL;$/;"	v
_libc_sigaction	main.c	/^int (* _libc_sigaction)(int, const struct sigaction *, struct sigaction *) = NULL;$/;"	v
ac_type	protocal.h	/^typedef enum { AC_READ=0, AC_WRITE=1 }ac_type;$/;"	t	typeref:enum:__anon2
acquire_ownership	protocal.c	/^void acquire_ownership (unsigned long page_start_addr, pid_t pid, ac_type type)$/;"	f
arg_num	libc.c	/^	int32 arg_num;$/;"	m	struct:libcfunc_event	file:
bool	protocal.c	/^typedef enum{false,true} bool;$/;"	t	typeref:enum:__anon3	file:
bool	test.c	/^typedef enum{false,true}bool;$/;"	t	typeref:enum:__anon5	file:
child1	test.c	/^void *child1(void *arg)$/;"	f
child2	test.c	/^void *child2(void *arg)$/;"	f
crew_prot	protocal.c	/^bool crew_prot(page_state ini_state, ac_type askfor_prio){$/;"	f
dend	main.c	/^unsigned long dstart,dend,dlenth;$/;"	v
dlenth	main.c	/^unsigned long dstart,dend,dlenth;$/;"	v
dstart	main.c	/^unsigned long dstart,dend,dlenth;$/;"	v
enable	global.h	/^	int enable;$/;"	m	struct:wait_item
false	protocal.c	/^typedef enum{false,true} bool;$/;"	e	enum:__anon3	file:
false	test.c	/^typedef enum{false,true}bool;$/;"	e	enum:__anon5	file:
flag	global.h	/^	volatile int flag;$/;"	m	struct:wait_item
func_id	libc.c	/^	int32 func_id;$/;"	m	struct:libcfunc_event	file:
give_up_ownership	protocal.c	/^void give_up_ownership (pid_t pid)$/;"	f
int32	libc.c	/^typedef int int32;$/;"	t	file:
libc_e	libc.c	/^}libc_e;$/;"	t	typeref:struct:libcfunc_event	file:
libcfunc_event	libc.c	/^typedef struct libcfunc_event {$/;"	s	file:
main	script.c	/^int main(int argc, char **argv)$/;"	f
main	test.c	/^int main (int argc, char **argv)$/;"	f
malloc	malloc.c	/^void* malloc(size_t size)$/;"	f
mode	main.c	/^int mode;\/\/0: record; 1: replay$/;"	v
owner	global.h	/^	pid_t owner;$/;"	m	struct:pot_item
page_fault_handler	main.c	/^static void page_fault_handler(int signum, siginfo_t *info, void *puc)$/;"	f	file:
page_start	global.h	/^	unsigned long page_start;$/;"	m	struct:pot_item
page_state	protocal.h	/^typedef enum { PUBLIC=0, SHARED_READ=1, OWNED_WRITE=2}page_state;$/;"	t	typeref:enum:__anon1
pid	libc.c	/^	pid_t pid;$/;"	m	struct:libcfunc_event	file:
pot_index	main.c	/^unsigned int *pot_index;$/;"	v
pot_item	global.h	/^struct pot_item$/;"	s
pot_item_init	main.c	/^void pot_item_init()$/;"	f
pot_lock	main.c	/^spinlock_t *pot_lock;$/;"	v
pot_table	main.c	/^struct pot_item *pot_table;$/;"	v	typeref:struct:pot_item
print_help	script.c	/^void print_help()$/;"	f
protect_memory	main.c	/^void protect_memory ()$/;"	f
protect_memory_init	main.c	/^void protect_memory_init()$/;"	f
protected	pthread.c	/^int protected = 0;$/;"	v
pthread_create	pthread.c	/^int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg)$/;"	f
pthread_join	pthread.c	/^int pthread_join(pthread_t thread, void **retval)$/;"	f
query_libcfunc	libc.c	/^char *query_libcfunc(int32 func_id, pid_t pid) {$/;"	f
read_mode_file	main.c	/^static void read_mode_file()$/;"	f	file:
real__libc_start_main	main.c	/^static int (* real__libc_start_main)(int (*) (int, char **, char **), int, char **, void (*)(void), void (*) (void), void (*) (void), void *) = NULL;$/;"	v	file:
retval	libc.c	/^	char retval[];$/;"	m	struct:libcfunc_event	file:
share_file_init	main.c	/^static void share_file_init()$/;"	f	file:
signal_init	main.c	/^static void signal_init()$/;"	f	file:
spin_lock	atomic.c	/^inline void spin_lock(spinlock_t *lock)$/;"	f
spin_trylock	atomic.c	/^inline int spin_trylock(spinlock_t *lock)$/;"	f
spin_unlock	atomic.c	/^inline void spin_unlock(spinlock_t *lock)$/;"	f
spinlock_t	global.h	/^typedef int spinlock_t;$/;"	t
start_cmd	script.c	/^void start_cmd(int argc, char **argv)$/;"	f
status	global.h	/^	page_state status;$/;"	m	struct:pot_item
testandset	atomic.c	/^static inline int testandset (int *p)$/;"	f	file:
true	protocal.c	/^typedef enum{false,true} bool;$/;"	e	enum:__anon3	file:
true	test.c	/^typedef enum{false,true}bool;$/;"	e	enum:__anon5	file:
uint32	libc.c	/^typedef unsigned int uint32;$/;"	t	file:
wait_item	global.h	/^struct wait_item$/;"	s
waiter	global.h	/^	struct wait_item waiter[10];$/;"	m	struct:pot_item	typeref:struct:pot_item::wait_item
waiter_number	global.h	/^	int waiter_number;$/;"	m	struct:pot_item
wrapper_gettimeofday	libc.c	/^int32 wrapper_gettimeofday(struct timeval *tp, struct timezone *tzp) {$/;"	f
wrapper_gettimeofday	libc.c	17;"	d	file:
write_libcfunc_log	libc.c	/^void write_libcfunc_log(libc_e *libc_info) {$/;"	f
write_mode_file	script.c	/^void write_mode_file (int mode)$/;"	f
x	test.c	/^int x = 0;$/;"	v
y	test.c	/^bool y = false;$/;"	v
